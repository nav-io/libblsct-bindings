diff --git a/src/blsct/range_proof/bulletproofs/range_proof_logic.cpp b/src/blsct/range_proof/bulletproofs/range_proof_logic.cpp
index c0d8a3ea3c..5c2fbd6791 100644
--- a/src/blsct/range_proof/bulletproofs/range_proof_logic.cpp
+++ b/src/blsct/range_proof/bulletproofs/range_proof_logic.cpp
@@ -14,7 +14,9 @@
 #include <blsct/range_proof/bulletproofs/range_proof_logic.h>
 #include <blsct/range_proof/common.h>
 #include <blsct/range_proof/msg_amt_cipher.h>
+#ifndef WASM_SINGLE_THREADED
 #include <future>
+#endif
 #include <optional>
 #include <stdexcept>
 #include <variant>
@@ -250,82 +252,91 @@ bool RangeProofLogic<T>::VerifyProofs(
     using Scalar = typename T::Scalar;
     using Scalars = Elements<Scalar>;
 
-    // Vector to hold future results from async tasks
-    std::vector<std::future<bool>> futures;
+    // Lambda to verify a single proof
+    auto verify_single = [this, max_mn](const RangeProofWithTranscript<T>& p) -> bool {
+        if (p.proof.Ls.Size() != p.proof.Rs.Size()) return false;
 
-    futures.reserve(proof_transcripts.size());
+        const range_proof::Generators<T> gens = m_common.Gf().GetInstance(p.proof.seed);
+        G_H_Gi_Hi_ZeroVerifier<T> verifier(max_mn);
 
-    // Launch a verification task for each proof transcript in parallel
-    for (const RangeProofWithTranscript<T>& p : proof_transcripts) {
-        futures.emplace_back(std::async(std::launch::async, [this, &p, max_mn]() -> bool {
-            if (p.proof.Ls.Size() != p.proof.Rs.Size()) return false;
+        auto num_rounds = range_proof::Common<T>::GetNumRoundsExclLast(p.proof.Vs.Size());
+        Scalar weight_y = Scalar::Rand();
+        Scalar weight_z = Scalar::Rand();
 
-            const range_proof::Generators<T> gens = m_common.Gf().GetInstance(p.proof.seed);
-            G_H_Gi_Hi_ZeroVerifier<T> verifier(max_mn);
+        Scalars z_pows_from_2 = Scalars::FirstNPow(p.z, p.num_input_values_power_2 + 1, 2); // z^2, z^3, ...
+        Scalar y_pows_sum = Scalars::FirstNPow(p.y, p.concat_input_values_in_bits).Sum();
 
-            auto num_rounds = range_proof::Common<T>::GetNumRoundsExclLast(p.proof.Vs.Size());
-            Scalar weight_y = Scalar::Rand();
-            Scalar weight_z = Scalar::Rand();
+        //////// (65)
+        verifier.AddNegativeH(p.proof.tau_x * weight_y);
 
-            Scalars z_pows_from_2 = Scalars::FirstNPow(p.z, p.num_input_values_power_2 + 1, 2); // z^2, z^3, ...
-            Scalar y_pows_sum = Scalars::FirstNPow(p.y, p.concat_input_values_in_bits).Sum();
+        Scalar delta_yz = p.z * y_pows_sum - (z_pows_from_2[0] * y_pows_sum);
+        for (size_t i = 1; i <= p.num_input_values_power_2; ++i) {
+            delta_yz = delta_yz - z_pows_from_2[i] * m_common.InnerProd1x2Pows64();
+        }
+
+        verifier.AddNegativeG((p.proof.t_hat - delta_yz) * weight_y);
 
-            //////// (65)
-            verifier.AddNegativeH(p.proof.tau_x * weight_y);
+        for (size_t i = 0; i < p.proof.Vs.Size(); ++i) {
+            verifier.AddPoint(LazyPoint<T>(p.proof.Vs[i] - (gens.G * p.proof.min_value), z_pows_from_2[i] * weight_y));
+        }
 
-            Scalar delta_yz = p.z * y_pows_sum - (z_pows_from_2[0] * y_pows_sum);
-            for (size_t i = 1; i <= p.num_input_values_power_2; ++i) {
-                delta_yz = delta_yz - z_pows_from_2[i] * m_common.InnerProd1x2Pows64();
-            }
+        verifier.AddPoint(LazyPoint<T>(p.proof.T1, p.x * weight_y));
+        verifier.AddPoint(LazyPoint<T>(p.proof.T2, p.x.Square() * weight_y));
 
-            verifier.AddNegativeG((p.proof.t_hat - delta_yz) * weight_y);
+        //////// (66)
+        verifier.AddPoint(LazyPoint<T>(p.proof.A, weight_z));
+        verifier.AddPoint(LazyPoint<T>(p.proof.S, p.x * weight_z));
 
-            for (size_t i = 0; i < p.proof.Vs.Size(); ++i) {
-                verifier.AddPoint(LazyPoint<T>(p.proof.Vs[i] - (gens.G * p.proof.min_value), z_pows_from_2[i] * weight_y));
-            }
+        //////// (67), (68)
+        auto gen_exps = ImpInnerProdArg::GenGeneratorExponents<T>(num_rounds, p.xs);
 
-            verifier.AddPoint(LazyPoint<T>(p.proof.T1, p.x * weight_y));
-            verifier.AddPoint(LazyPoint<T>(p.proof.T2, p.x.Square() * weight_y));
+        ImpInnerProdArg::LoopWithYPows<Mcl>(p.concat_input_values_in_bits, p.y,
+                                            [&](const size_t& i, const Scalar& y_pow, const Scalar& y_inv_pow) {
+                                                Scalar gi_exp = p.proof.a * gen_exps[i];
+                                                Scalar hi_exp = p.proof.b * y_inv_pow * gen_exps[p.concat_input_values_in_bits - 1 - i];
 
-            //////// (66)
-            verifier.AddPoint(LazyPoint<T>(p.proof.A, weight_z));
-            verifier.AddPoint(LazyPoint<T>(p.proof.S, p.x * weight_z));
+                                                gi_exp = gi_exp + p.z;
 
-            //////// (67), (68)
-            auto gen_exps = ImpInnerProdArg::GenGeneratorExponents<T>(num_rounds, p.xs);
+                                                Scalar tmp = z_pows_from_2[i / range_proof::Setup::num_input_value_bits] *
+                                                             m_common.TwoPows64()[i % range_proof::Setup::num_input_value_bits];
 
-            ImpInnerProdArg::LoopWithYPows<Mcl>(p.concat_input_values_in_bits, p.y,
-                                                [&](const size_t& i, const Scalar& y_pow, const Scalar& y_inv_pow) {
-                                                    Scalar gi_exp = p.proof.a * gen_exps[i];
-                                                    Scalar hi_exp = p.proof.b * y_inv_pow * gen_exps[p.concat_input_values_in_bits - 1 - i];
+                                                hi_exp = hi_exp - (tmp + p.z * y_pow) * y_inv_pow;
 
-                                                    gi_exp = gi_exp + p.z;
+                                                verifier.SetGiExp(i, (gi_exp * weight_z).Negate());
+                                                verifier.SetHiExp(i, (hi_exp * weight_z).Negate());
+                                            });
 
-                                                    Scalar tmp = z_pows_from_2[i / range_proof::Setup::num_input_value_bits] *
-                                                                 m_common.TwoPows64()[i % range_proof::Setup::num_input_value_bits];
+        verifier.AddNegativeH(p.proof.mu * weight_z);
+        auto x_invs = p.xs.Invert();
 
-                                                    hi_exp = hi_exp - (tmp + p.z * y_pow) * y_inv_pow;
+        for (size_t i = 0; i < num_rounds; ++i) {
+            verifier.AddPoint(LazyPoint<T>(p.proof.Ls[i], p.xs[i].Square() * weight_z));
+            verifier.AddPoint(LazyPoint<T>(p.proof.Rs[i], x_invs[i].Square() * weight_z));
+        }
 
-                                                    verifier.SetGiExp(i, (gi_exp * weight_z).Negate());
-                                                    verifier.SetHiExp(i, (hi_exp * weight_z).Negate());
-                                                });
+        verifier.AddPositiveG((p.proof.t_hat - p.proof.a * p.proof.b) * p.c_factor * weight_z);
 
-            verifier.AddNegativeH(p.proof.mu * weight_z);
-            auto x_invs = p.xs.Invert();
+        return verifier.Verify(
+            gens.G,
+            gens.H,
+            gens.GetGiSubset(max_mn),
+            gens.GetHiSubset(max_mn));
+    };
 
-            for (size_t i = 0; i < num_rounds; ++i) {
-                verifier.AddPoint(LazyPoint<T>(p.proof.Ls[i], p.xs[i].Square() * weight_z));
-                verifier.AddPoint(LazyPoint<T>(p.proof.Rs[i], x_invs[i].Square() * weight_z));
-            }
+#ifdef WASM_SINGLE_THREADED
+    // Single-threaded: verify proofs sequentially
+    for (const RangeProofWithTranscript<T>& p : proof_transcripts) {
+        if (!verify_single(p)) return false;
+    }
+#else
+    // Multi-threaded: verify proofs in parallel using std::async
+    std::vector<std::future<bool>> futures;
 
-            verifier.AddPositiveG((p.proof.t_hat - p.proof.a * p.proof.b) * p.c_factor * weight_z);
+    futures.reserve(proof_transcripts.size());
 
-            bool res = verifier.Verify(
-                gens.G,
-                gens.H,
-                gens.GetGiSubset(max_mn),
-                gens.GetHiSubset(max_mn));
-            return res;
+    for (const RangeProofWithTranscript<T>& p : proof_transcripts) {
+        futures.emplace_back(std::async(std::launch::async, [&verify_single, &p]() -> bool {
+            return verify_single(p);
         }));
     }
 
@@ -333,6 +344,7 @@ bool RangeProofLogic<T>::VerifyProofs(
     for (auto& fut : futures) {
         if (!fut.get()) return false;
     }
+#endif
 
     return true;
 }
diff --git a/src/blsct/range_proof/bulletproofs_plus/range_proof_logic.cpp b/src/blsct/range_proof/bulletproofs_plus/range_proof_logic.cpp
index 2c2c3c364d..d0b657f4c6 100644
--- a/src/blsct/range_proof/bulletproofs_plus/range_proof_logic.cpp
+++ b/src/blsct/range_proof/bulletproofs_plus/range_proof_logic.cpp
@@ -13,7 +13,9 @@
 #include <blsct/range_proof/bulletproofs_plus/range_proof_logic.h>
 #include <blsct/range_proof/common.h>
 #include <blsct/range_proof/msg_amt_cipher.h>
+#ifndef WASM_SINGLE_THREADED
 #include <future>
+#endif
 #include <tinyformat.h>
 
 // Bulletproofs+ implementation based on
@@ -405,111 +407,116 @@ bool RangeProofLogic<T>::VerifyProofs(
     using Scalar = typename T::Scalar;
     using Scalars = Elements<Scalar>;
 
-    // Vector to hold future results from async tasks
-    std::vector<std::future<bool>> futures;
+    // Lambda to verify a single proof
+    auto verify_single = [this](const RangeProofWithTranscript<T>& pt) -> bool {
+        if (pt.proof.Ls.Size() != pt.proof.Rs.Size()) return false;
 
-    // Atomic flag to signal abort
-    std::atomic<bool> abort_flag(false);
+        range_proof::Generators<T> gens = m_common.Gf().GetInstance(pt.proof.seed);
 
-    futures.reserve(proof_transcripts.size());
-
-    for (const RangeProofWithTranscript<T>& pt : proof_transcripts) {
-        futures.emplace_back(std::async(std::launch::async, [this, &pt, &abort_flag]() -> bool {
-            if (abort_flag.load()) return false; // Early exit if another task has already failed
+        auto gs = gens.GetGiSubset(pt.mn);
+        auto hs = gens.GetHiSubset(pt.mn);
+        auto h = gens.H;
+        auto g = gens.G;
 
-            if (pt.proof.Ls.Size() != pt.proof.Rs.Size()) return false;
+        auto [two_pows,
+              y_asc_pows_mn,
+              y_desc_pows_mn,
+              z_asc_by_2_pows,
+              y_to_mn_plus_1] = RangeProofLogic<T>::ComputePowers(pt.y, pt.z, pt.m, pt.n);
 
-            range_proof::Generators<T> gens = m_common.Gf().GetInstance(pt.proof.seed);
-
-            auto gs = gens.GetGiSubset(pt.mn);
-            auto hs = gens.GetHiSubset(pt.mn);
-            auto h = gens.H;
-            auto g = gens.G;
-
-            auto [two_pows,
-                  y_asc_pows_mn,
-                  y_desc_pows_mn,
-                  z_asc_by_2_pows,
-                  y_to_mn_plus_1] = RangeProofLogic<T>::ComputePowers(pt.y, pt.z, pt.m, pt.n);
-
-            // Compute: z^2 * 1, ..., z^2 * 2^n-1, z^4 * 1, ..., z^4 * 2^n-1, z^6 * 1, ...
-            Scalars z_times_two_pows;
-            {
-                for (auto z_pow : z_asc_by_2_pows.m_vec) {
-                    for (auto two_pow : two_pows.m_vec) {
-                        z_times_two_pows.Add(z_pow * two_pow);
-                    }
+        // Compute: z^2 * 1, ..., z^2 * 2^n-1, z^4 * 1, ..., z^4 * 2^n-1, z^6 * 1, ...
+        Scalars z_times_two_pows;
+        {
+            for (auto z_pow : z_asc_by_2_pows.m_vec) {
+                for (auto two_pow : two_pows.m_vec) {
+                    z_times_two_pows.Add(z_pow * two_pow);
                 }
             }
+        }
 
-            // Compute scalars for verification
-            auto [e_squares,
-                  e_inv_squares,
-                  s_vec] = RangeProofLogic<T>::ComputeVeriScalars(pt.es, pt.mn);
-
-            Scalars s_prime_vec = s_vec.Reverse();
-            Scalar inv_final_e = pt.e_last_round.Invert();
-            Scalar final_e_sq = pt.e_last_round.Square();
-            Scalar inv_final_e_sq = final_e_sq.Invert();
-            Scalar r_prime_inv_final_e_y = pt.proof.r_prime * inv_final_e * pt.y;
-            Scalar s_prime_inv_final_e = pt.proof.s_prime * inv_final_e;
-            Scalars inv_y_asc_pows_mn = Scalars::FirstNPow(pt.y.Invert(), pt.mn, 1); // skip first 1
-
-            // Compute generator exponents
-            Scalars gs_exp;
-            {
-                Scalar minus_z = pt.z.Negate();
-                for (size_t i = 0; i < pt.mn; ++i) {
-                    Scalar s = s_vec[i];
-                    Scalar inv_y_pow = inv_y_asc_pows_mn[i];
-                    gs_exp.Add(minus_z + s.Negate() * inv_y_pow * r_prime_inv_final_e_y);
-                }
+        // Compute scalars for verification
+        auto [e_squares,
+              e_inv_squares,
+              s_vec] = RangeProofLogic<T>::ComputeVeriScalars(pt.es, pt.mn);
+
+        Scalars s_prime_vec = s_vec.Reverse();
+        Scalar inv_final_e = pt.e_last_round.Invert();
+        Scalar final_e_sq = pt.e_last_round.Square();
+        Scalar inv_final_e_sq = final_e_sq.Invert();
+        Scalar r_prime_inv_final_e_y = pt.proof.r_prime * inv_final_e * pt.y;
+        Scalar s_prime_inv_final_e = pt.proof.s_prime * inv_final_e;
+        Scalars inv_y_asc_pows_mn = Scalars::FirstNPow(pt.y.Invert(), pt.mn, 1); // skip first 1
+
+        // Compute generator exponents
+        Scalars gs_exp;
+        {
+            Scalar minus_z = pt.z.Negate();
+            for (size_t i = 0; i < pt.mn; ++i) {
+                Scalar s = s_vec[i];
+                Scalar inv_y_pow = inv_y_asc_pows_mn[i];
+                gs_exp.Add(minus_z + s.Negate() * inv_y_pow * r_prime_inv_final_e_y);
             }
+        }
 
-            Scalars hs_exp;
-            {
-                Scalar neg_s_prime_inv_final_e = s_prime_inv_final_e.Negate();
-                for (size_t i = 0; i < pt.mn; ++i) {
-                    Scalar rev_s = s_vec[pt.mn - 1 - i];
-                    Scalar z_times_two_pow = z_times_two_pows[i];
-                    Scalar y_pow_desc = y_desc_pows_mn[i];
-                    hs_exp.Add(
-                        neg_s_prime_inv_final_e * rev_s + z_times_two_pow * y_pow_desc + pt.z);
-                }
+        Scalars hs_exp;
+        {
+            Scalar neg_s_prime_inv_final_e = s_prime_inv_final_e.Negate();
+            for (size_t i = 0; i < pt.mn; ++i) {
+                Scalar rev_s = s_vec[pt.mn - 1 - i];
+                Scalar z_times_two_pow = z_times_two_pows[i];
+                Scalar y_pow_desc = y_desc_pows_mn[i];
+                hs_exp.Add(
+                    neg_s_prime_inv_final_e * rev_s + z_times_two_pow * y_pow_desc + pt.z);
             }
+        }
 
-            Scalar g_exp =
-                pt.proof.r_prime.Negate() * pt.proof.s_prime * pt.y * inv_final_e_sq + (y_asc_pows_mn.Sum() * (pt.z + pt.z.Square().Negate()) + y_to_mn_plus_1.Negate() * pt.z * two_pows.Sum() * z_asc_by_2_pows.Sum());
-            Scalar h_exp = pt.proof.delta_prime.Negate() * inv_final_e_sq;
+        Scalar g_exp =
+            pt.proof.r_prime.Negate() * pt.proof.s_prime * pt.y * inv_final_e_sq + (y_asc_pows_mn.Sum() * (pt.z + pt.z.Square().Negate()) + y_to_mn_plus_1.Negate() * pt.z * two_pows.Sum() * z_asc_by_2_pows.Sum());
+        Scalar h_exp = pt.proof.delta_prime.Negate() * inv_final_e_sq;
 
-            Scalars vs_exp;
-            {
-                for (auto x : z_asc_by_2_pows.m_vec) {
-                    vs_exp.Add(x * y_to_mn_plus_1);
-                }
+        Scalars vs_exp;
+        {
+            for (auto x : z_asc_by_2_pows.m_vec) {
+                vs_exp.Add(x * y_to_mn_plus_1);
             }
+        }
 
-            LazyPoints<T> lp;
-            lp.Add(pt.proof.A);
-            lp.Add(pt.proof.A_wip, pt.e_last_round.Invert());
-            lp.Add(pt.proof.B, pt.e_last_round.Square().Invert());
-            lp.Add(g, g_exp);
-            lp.Add(h, h_exp);
-            lp.Add(pt.proof.Ls, static_cast<const Scalars&>(e_squares));
-            lp.Add(pt.proof.Rs, e_inv_squares);
-            lp.Add(gs, gs_exp);
-            lp.Add(hs, hs_exp);
-
-            for (size_t i = 0; i < pt.proof.Vs.Size(); ++i) {
-                lp.Add(LazyPoint<T>(pt.proof.Vs[i] - (gens.G * pt.proof.min_value), vs_exp[i]));
-            }
+        LazyPoints<T> lp;
+        lp.Add(pt.proof.A);
+        lp.Add(pt.proof.A_wip, pt.e_last_round.Invert());
+        lp.Add(pt.proof.B, pt.e_last_round.Square().Invert());
+        lp.Add(g, g_exp);
+        lp.Add(h, h_exp);
+        lp.Add(pt.proof.Ls, static_cast<const Scalars&>(e_squares));
+        lp.Add(pt.proof.Rs, e_inv_squares);
+        lp.Add(gs, gs_exp);
+        lp.Add(hs, hs_exp);
+
+        for (size_t i = 0; i < pt.proof.Vs.Size(); ++i) {
+            lp.Add(LazyPoint<T>(pt.proof.Vs[i] - (gens.G * pt.proof.min_value), vs_exp[i]));
+        }
 
-            if (!lp.Sum().IsZero()) {
-                abort_flag.store(true); // Signal abort if verification fails
-                return false;
-            }
+        return lp.Sum().IsZero();
+    };
 
-            return true;
+#ifdef WASM_SINGLE_THREADED
+    // Single-threaded: verify proofs sequentially
+    for (const RangeProofWithTranscript<T>& pt : proof_transcripts) {
+        if (!verify_single(pt)) return false;
+    }
+#else
+    // Multi-threaded: verify proofs in parallel using std::async
+    std::vector<std::future<bool>> futures;
+    std::atomic<bool> abort_flag(false);
+
+    futures.reserve(proof_transcripts.size());
+
+    for (const RangeProofWithTranscript<T>& pt : proof_transcripts) {
+        futures.emplace_back(std::async(std::launch::async, [&verify_single, &pt, &abort_flag]() -> bool {
+            if (abort_flag.load()) return false;
+            bool result = verify_single(pt);
+            if (!result) abort_flag.store(true);
+            return result;
         }));
     }
 
@@ -517,6 +524,7 @@ bool RangeProofLogic<T>::VerifyProofs(
     for (auto& fut : futures) {
         if (!fut.get()) return false;
     }
+#endif
 
     return true;
 }
